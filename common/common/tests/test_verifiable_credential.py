# SPDX-FileCopyrightText: 2024 Swiss Confederation
#
# SPDX-License-Identifier: MIT

import datetime

import pydantic

import common.verifiable_credential as vc

# TODO: How to create these examples
OID_CREDENTIAL = '{"format": "jwt_vc", "credential": "eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzUxMiJ9.eyJpc3MiOiJodHRwczovL3JlZ2lzdHJ5X2Jhc2UvaXNzdWVyLzcyZDkwYjQ0LWZkM2MtNDYzOC1hZWM3LTBiNjFhM2ZlOGM5ZCIsInN1YiI6ImRpZDpqd2s6ZXlKamNuWWlPaUFpVUMwMU1qRWlMQ0FpZUNJNklDSXpUWEZVWVVKclMxOWpTMjFPWkdWM1VWRTNjVnBpVFROWlVHaG5MWE5sYXpObVdrZHBWMHRUWWtGSVNFSk5lSE5GTUhCc2EycDRkbWRsY3pOdlVrcG5UVlo2Umw5VFoxWm9NRzEzYkdVeFdFVklhemxJWlhNaUxDQWllU0k2SUNKQllUQnlOMHRSUzJnM1UyTk5TRUZqY25wT2FYUTNWSFJGYnpkR1NsRkNUM1JGZDNVeVJubEhaa3hwWDFBMVlubG5RekYwT1U5RVUySXpSbXhoT0dOdk1rYzRSV05YYVROMk0wNUpTVzk0YTBadVFtRTRhRUkwSWl3Z0ltdDBlU0k2SUNKRlF5SXNJQ0pyYVdRaU9pQWlWMk5uWW01MFQzcFJZakpSY3pSTGIwTmxiRnAyZDFKTU5HTlZXVGRXVjBkRVVHUk9aVVZxYWtOUlNTSjkiLCJleHAiOjE3MjU2MTEyMzAsImlhdCI6MTY5NTM3MTIzMCwianRpIjoiaHR0cHM6Ly9pc3N1ZXIvM2QyMGFlODUtMTI4Zi00YzMwLWE2MDUtNjA2M2NiN2U0YzI5IiwiY25mIjp7Imt0eSI6IkVDIiwia2lkIjoiV2NnYm50T3pRYjJRczRLb0NlbFp2d1JMNGNVWTdWV0dEUGROZUVqakNRSSIsImNydiI6IlAtNTIxIiwieCI6IjNNcVRhQmtLX2NLbU5kZXdRUTdxWmJNM1lQaGctc2VrM2ZaR2lXS1NiQUhIQk14c0UwcGxranh2Z2VzM29SSmdNVnpGX1NnVmgwbXdsZTFYRUhrOUhlcyIsInkiOiJBYTByN0tRS2g3U2NNSEFjcnpOaXQ3VHRFbzdGSlFCT3RFd3UyRnlHZkxpX1A1YnlnQzF0OU9EU2IzRmxhOGNvMkc4RWNXaTN2M05JSW94a0ZuQmE4aEI0IiwiYmFzZTY0IjoiSW50Y0ltdDBlVndpT2x3aVJVTmNJaXhjSW10cFpGd2lPbHdpVjJOblltNTBUM3BSWWpKUmN6UkxiME5sYkZwMmQxSk1OR05WV1RkV1YwZEVVR1JPWlVWcWFrTlJTVndpTEZ3aVkzSjJYQ0k2WENKUUxUVXlNVndpTEZ3aWVGd2lPbHdpTTAxeFZHRkNhMHRmWTB0dFRtUmxkMUZSTjNGYVlrMHpXVkJvWnkxelpXc3pabHBIYVZkTFUySkJTRWhDVFhoelJUQndiR3RxZUhablpYTXpiMUpLWjAxV2VrWmZVMmRXYURCdGQyeGxNVmhGU0dzNVNHVnpYQ0lzWENKNVhDSTZYQ0pCWVRCeU4wdFJTMmczVTJOTlNFRmpjbnBPYVhRM1ZIUkZiemRHU2xGQ1QzUkZkM1V5Um5sSFpreHBYMUExWW5sblF6RjBPVTlFVTJJelJteGhPR052TWtjNFJXTlhhVE4yTTA1SlNXOTRhMFp1UW1FNGFFSTBYQ0o5SWc9PSJ9LCJ2YyI6eyJpZCI6Imh0dHBzOi8vaXNzdWVyLzNkMjBhZTg1LTEyOGYtNGMzMC1hNjA1LTYwNjNjYjdlNGMyOSIsInR5cGUiOlsiVmVyaWZpYWJsZUNyZWRlbnRpYWwiLCJVbml2ZXJzaXR5RGVncmVlQ3JlZGVudGlhbCJdLCJpc3N1ZXIiOiJodHRwczovL3JlZ2lzdHJ5X2Jhc2UvaXNzdWVyLzcyZDkwYjQ0LWZkM2MtNDYzOC1hZWM3LTBiNjFhM2ZlOGM5ZCIsImNyZWRlbnRpYWxTdWJqZWN0Ijp7ImlkIjoiZGlkOmp3azpleUpqY25ZaU9pQWlVQzAxTWpFaUxDQWllQ0k2SUNJelRYRlVZVUpyUzE5alMyMU9aR1YzVVZFM2NWcGlUVE5aVUdobkxYTmxhek5tV2tkcFYwdFRZa0ZJU0VKTmVITkZNSEJzYTJwNGRtZGxjek52VWtwblRWWjZSbDlUWjFab01HMTNiR1V4V0VWSWF6bElaWE1pTENBaWVTSTZJQ0pCWVRCeU4wdFJTMmczVTJOTlNFRmpjbnBPYVhRM1ZIUkZiemRHU2xGQ1QzUkZkM1V5Um5sSFpreHBYMUExWW5sblF6RjBPVTlFVTJJelJteGhPR052TWtjNFJXTlhhVE4yTTA1SlNXOTRhMFp1UW1FNGFFSTBJaXdnSW10MGVTSTZJQ0pGUXlJc0lDSnJhV1FpT2lBaVYyTm5ZbTUwVDNwUllqSlJjelJMYjBObGJGcDJkMUpNTkdOVldUZFdWMGRFVUdST1pVVnFha05SU1NKOSIsImRlZ3JlZSI6eyJ0eXBlIjoiQmFjaGVsb3JEZWdyZWUiLCJuYW1lIjoiQmFjaGVsb3Igb2YgU2NpZW5jZSIsImF2ZXJhZ2VfZ3JhZGUiOjQuMTh9fSwiY3JlZGVudGlhbFN0YXR1cyI6eyJpZCI6Imh0dHBzOi8vcmVnaXN0cnlfcmV2b2NhdGlvbi9pc3N1ZXIvNzJkOTBiNDQtZmQzYy00NjM4LWFlYzctMGI2MWEzZmU4YzlkL3N0YXR1c2xpc3QvNmQyODA3NzktMGZhMi00Y2I3LWEzMDYtNDU3M2Q2ODVkZmQ0IzI0OCIsInR5cGUiOiJTdGF0dXNMaXN0MjAyMUVudHJ5Iiwic3RhdHVzUHVycG9zZSI6InJldm9jYXRpb24iLCJzdGF0dXNMaXN0SW5kZXgiOiIyNDgiLCJzdGF0dXNMaXN0Q3JlZGVudGlhbCI6Imh0dHBzOi8vcmVnaXN0cnlfYmFzZS9pc3N1ZXIvNzJkOTBiNDQtZmQzYy00NjM4LWFlYzctMGI2MWEzZmU4YzlkIn19fQ.AeAy6ktLpSl3jawBEjAhhhBx49Vsx66jxeyV8cVMSD2-J9g6NkN4pyx1lkmEY0yCFSxpsqnIbVI0ctwr6oci954hAe8v_rsnC1Z2Q7gCqLQF-TPyKL4_7z23TLDvLAXmJaKXlZ5XLNL-qSRZA5viwWWrEIwg6dIb6XGXh3ZHiCrvsiDp"}'
OID_SD_CREDENTIAL_ALL_DISCLOSED = '{"format": "jwt_vc", "credential": "eyJhbGciOiAiRVM1MTIifQ.eyJpc3MiOiAiaHR0cHM6Ly9yZWdpc3RyeV9iYXNlL2lzc3Vlci83MmQ5MGI0NC1mZDNjLTQ2MzgtYWVjNy0wYjYxYTNmZThjOWQiLCAic3ViIjogImRpZDpqd2s6ZXlKamNuWWlPaUFpVUMwMU1qRWlMQ0FpZUNJNklDSXpUWEZVWVVKclMxOWpTMjFPWkdWM1VWRTNjVnBpVFROWlVHaG5MWE5sYXpObVdrZHBWMHRUWWtGSVNFSk5lSE5GTUhCc2EycDRkbWRsY3pOdlVrcG5UVlo2Umw5VFoxWm9NRzEzYkdVeFdFVklhemxJWlhNaUxDQWllU0k2SUNKQllUQnlOMHRSUzJnM1UyTk5TRUZqY25wT2FYUTNWSFJGYnpkR1NsRkNUM1JGZDNVeVJubEhaa3hwWDFBMVlubG5RekYwT1U5RVUySXpSbXhoT0dOdk1rYzRSV05YYVROMk0wNUpTVzk0YTBadVFtRTRhRUkwSWl3Z0ltdDBlU0k2SUNKRlF5SXNJQ0pyYVdRaU9pQWlWMk5uWW01MFQzcFJZakpSY3pSTGIwTmxiRnAyZDFKTU5HTlZXVGRXVjBkRVVHUk9aVVZxYWtOUlNTSjkiLCAiZXhwIjogMTcyNTYxMTI3NCwgImlhdCI6IDE2OTUzNzEyNzQsICJqdGkiOiAiaHR0cHM6Ly9pc3N1ZXIvNjU3MmE3MjYtYmFlYS00ZmNlLTkyZGQtNjQwYjk1YjhjOTk5IiwgImNuZiI6IHsia3R5IjogIkVDIiwgImtpZCI6ICJXY2dibnRPelFiMlFzNEtvQ2VsWnZ3Ukw0Y1VZN1ZXR0RQZE5lRWpqQ1FJIiwgImNydiI6ICJQLTUyMSIsICJ4IjogIjNNcVRhQmtLX2NLbU5kZXdRUTdxWmJNM1lQaGctc2VrM2ZaR2lXS1NiQUhIQk14c0UwcGxranh2Z2VzM29SSmdNVnpGX1NnVmgwbXdsZTFYRUhrOUhlcyIsICJ5IjogIkFhMHI3S1FLaDdTY01IQWNyek5pdDdUdEVvN0ZKUUJPdEV3dTJGeUdmTGlfUDVieWdDMXQ5T0RTYjNGbGE4Y28yRzhFY1dpM3YzTklJb3hrRm5CYThoQjQiLCAiYmFzZTY0IjogIkludGNJbXQwZVZ3aU9sd2lSVU5jSWl4Y0ltdHBaRndpT2x3aVYyTm5ZbTUwVDNwUllqSlJjelJMYjBObGJGcDJkMUpNTkdOVldUZFdWMGRFVUdST1pVVnFha05SU1Z3aUxGd2lZM0oyWENJNlhDSlFMVFV5TVZ3aUxGd2llRndpT2x3aU0wMXhWR0ZDYTB0ZlkwdHRUbVJsZDFGUk4zRmFZazB6V1ZCb1p5MXpaV3N6WmxwSGFWZExVMkpCU0VoQ1RYaHpSVEJ3Ykd0cWVIWm5aWE16YjFKS1owMVdla1pmVTJkV2FEQnRkMnhsTVZoRlNHczVTR1Z6WENJc1hDSjVYQ0k2WENKQllUQnlOMHRSUzJnM1UyTk5TRUZqY25wT2FYUTNWSFJGYnpkR1NsRkNUM1JGZDNVeVJubEhaa3hwWDFBMVlubG5RekYwT1U5RVUySXpSbXhoT0dOdk1rYzRSV05YYVROMk0wNUpTVzk0YTBadVFtRTRhRUkwWENKOUlnPT0ifSwgInZjIjogeyJpZCI6ICJodHRwczovL2lzc3Vlci82NTcyYTcyNi1iYWVhLTRmY2UtOTJkZC02NDBiOTViOGM5OTkiLCAidHlwZSI6IFsiVmVyaWZpYWJsZUNyZWRlbnRpYWwiLCAiVW5pdmVyc2l0eURlZ3JlZUNyZWRlbnRpYWwiXSwgImlzc3VlciI6ICJodHRwczovL3JlZ2lzdHJ5X2Jhc2UvaXNzdWVyLzcyZDkwYjQ0LWZkM2MtNDYzOC1hZWM3LTBiNjFhM2ZlOGM5ZCIsICJjcmVkZW50aWFsU3ViamVjdCI6IHsiZGVncmVlIjogeyJfc2QiOiBbIk9mNk9sNjQ1Qkg3Q0MwcjA0UnR3Y0xrWDZucVRBbTRrTDFQaEFKaUZQV2MiLCAiYlpqZ0lDWTZMNmx2U1lQbmxHdTgtblNHbnB5STg2NVdobFV4OU1XQlJHMCIsICJrcHYyR3A2S0ZyNHdNdThEbmF4ckEteG5mYlZCQUk5RElwUkFpLTU5dzBRIl19LCAiaWQiOiAiZGlkOmp3azpleUpqY25ZaU9pQWlVQzAxTWpFaUxDQWllQ0k2SUNJelRYRlVZVUpyUzE5alMyMU9aR1YzVVZFM2NWcGlUVE5aVUdobkxYTmxhek5tV2tkcFYwdFRZa0ZJU0VKTmVITkZNSEJzYTJwNGRtZGxjek52VWtwblRWWjZSbDlUWjFab01HMTNiR1V4V0VWSWF6bElaWE1pTENBaWVTSTZJQ0pCWVRCeU4wdFJTMmczVTJOTlNFRmpjbnBPYVhRM1ZIUkZiemRHU2xGQ1QzUkZkM1V5Um5sSFpreHBYMUExWW5sblF6RjBPVTlFVTJJelJteGhPR052TWtjNFJXTlhhVE4yTTA1SlNXOTRhMFp1UW1FNGFFSTBJaXdnSW10MGVTSTZJQ0pGUXlJc0lDSnJhV1FpT2lBaVYyTm5ZbTUwVDNwUllqSlJjelJMYjBObGJGcDJkMUpNTkdOVldUZFdWMGRFVUdST1pVVnFha05SU1NKOSJ9LCAiY3JlZGVudGlhbFN0YXR1cyI6IHsiaWQiOiAiaHR0cHM6Ly9yZWdpc3RyeV9yZXZvY2F0aW9uL2lzc3Vlci83MmQ5MGI0NC1mZDNjLTQ2MzgtYWVjNy0wYjYxYTNmZThjOWQvc3RhdHVzbGlzdC82ZDI4MDc3OS0wZmEyLTRjYjctYTMwNi00NTczZDY4NWRmZDQjMjQ5IiwgInR5cGUiOiAiU3RhdHVzTGlzdDIwMjFFbnRyeSIsICJzdGF0dXNQdXJwb3NlIjogInJldm9jYXRpb24iLCAic3RhdHVzTGlzdEluZGV4IjogIjI0OSIsICJzdGF0dXNMaXN0Q3JlZGVudGlhbCI6ICJodHRwczovL3JlZ2lzdHJ5X2Jhc2UvaXNzdWVyLzcyZDkwYjQ0LWZkM2MtNDYzOC1hZWM3LTBiNjFhM2ZlOGM5ZCJ9fSwgIl9zZF9hbGciOiAic2hhLTI1NiJ9.AQhQKRWjyqH-AlBiQFR273KjiNx9KiuAS0Kg8oMsWK8bcZBzrxp0u6v8Lt135uILMqPdB6BR9O391Mlos_OfbMVXAO6hpS2cnwbhgsPmyVXrQo7tBFhJuetoBJyJW0UVKmIMEeHeCAO64EPlZtvfgejy1P29ZUMf8zJH-_pHh8vyDwys~WyJhTGZoRl9CRWh0NWtxX2RnZGhFaTJBIiwgInR5cGUiLCAiTWFzdGVyRGVncmVlIl0~WyJvZ0tfNVlJVko1QnNRaWswUE1kWEdRIiwgIm5hbWUiLCAiTWFzdGVyIG9mIFNjaWVuY2UiXQ~WyJ5UVRUQ2J6QXkyR09uY2N6WWRPaU5RIiwgImF2ZXJhZ2VfZ3JhZGUiLCA0LjIxXQ~"}'
OID_SD_CREDENTIAL_PARTS_DISCLOSED = '{"format": "jwt_vc", "credential": "eyJhbGciOiAiRVM1MTIifQ.eyJpc3MiOiAiaHR0cHM6Ly9yZWdpc3RyeV9iYXNlL2lzc3Vlci83MmQ5MGI0NC1mZDNjLTQ2MzgtYWVjNy0wYjYxYTNmZThjOWQiLCAic3ViIjogImRpZDpqd2s6ZXlKamNuWWlPaUFpVUMwMU1qRWlMQ0FpZUNJNklDSXpUWEZVWVVKclMxOWpTMjFPWkdWM1VWRTNjVnBpVFROWlVHaG5MWE5sYXpObVdrZHBWMHRUWWtGSVNFSk5lSE5GTUhCc2EycDRkbWRsY3pOdlVrcG5UVlo2Umw5VFoxWm9NRzEzYkdVeFdFVklhemxJWlhNaUxDQWllU0k2SUNKQllUQnlOMHRSUzJnM1UyTk5TRUZqY25wT2FYUTNWSFJGYnpkR1NsRkNUM1JGZDNVeVJubEhaa3hwWDFBMVlubG5RekYwT1U5RVUySXpSbXhoT0dOdk1rYzRSV05YYVROMk0wNUpTVzk0YTBadVFtRTRhRUkwSWl3Z0ltdDBlU0k2SUNKRlF5SXNJQ0pyYVdRaU9pQWlWMk5uWW01MFQzcFJZakpSY3pSTGIwTmxiRnAyZDFKTU5HTlZXVGRXVjBkRVVHUk9aVVZxYWtOUlNTSjkiLCAiZXhwIjogMTcyNTYxMTI3NCwgImlhdCI6IDE2OTUzNzEyNzQsICJqdGkiOiAiaHR0cHM6Ly9pc3N1ZXIvNjU3MmE3MjYtYmFlYS00ZmNlLTkyZGQtNjQwYjk1YjhjOTk5IiwgImNuZiI6IHsia3R5IjogIkVDIiwgImtpZCI6ICJXY2dibnRPelFiMlFzNEtvQ2VsWnZ3Ukw0Y1VZN1ZXR0RQZE5lRWpqQ1FJIiwgImNydiI6ICJQLTUyMSIsICJ4IjogIjNNcVRhQmtLX2NLbU5kZXdRUTdxWmJNM1lQaGctc2VrM2ZaR2lXS1NiQUhIQk14c0UwcGxranh2Z2VzM29SSmdNVnpGX1NnVmgwbXdsZTFYRUhrOUhlcyIsICJ5IjogIkFhMHI3S1FLaDdTY01IQWNyek5pdDdUdEVvN0ZKUUJPdEV3dTJGeUdmTGlfUDVieWdDMXQ5T0RTYjNGbGE4Y28yRzhFY1dpM3YzTklJb3hrRm5CYThoQjQiLCAiYmFzZTY0IjogIkludGNJbXQwZVZ3aU9sd2lSVU5jSWl4Y0ltdHBaRndpT2x3aVYyTm5ZbTUwVDNwUllqSlJjelJMYjBObGJGcDJkMUpNTkdOVldUZFdWMGRFVUdST1pVVnFha05SU1Z3aUxGd2lZM0oyWENJNlhDSlFMVFV5TVZ3aUxGd2llRndpT2x3aU0wMXhWR0ZDYTB0ZlkwdHRUbVJsZDFGUk4zRmFZazB6V1ZCb1p5MXpaV3N6WmxwSGFWZExVMkpCU0VoQ1RYaHpSVEJ3Ykd0cWVIWm5aWE16YjFKS1owMVdla1pmVTJkV2FEQnRkMnhsTVZoRlNHczVTR1Z6WENJc1hDSjVYQ0k2WENKQllUQnlOMHRSUzJnM1UyTk5TRUZqY25wT2FYUTNWSFJGYnpkR1NsRkNUM1JGZDNVeVJubEhaa3hwWDFBMVlubG5RekYwT1U5RVUySXpSbXhoT0dOdk1rYzRSV05YYVROMk0wNUpTVzk0YTBadVFtRTRhRUkwWENKOUlnPT0ifSwgInZjIjogeyJpZCI6ICJodHRwczovL2lzc3Vlci82NTcyYTcyNi1iYWVhLTRmY2UtOTJkZC02NDBiOTViOGM5OTkiLCAidHlwZSI6IFsiVmVyaWZpYWJsZUNyZWRlbnRpYWwiLCAiVW5pdmVyc2l0eURlZ3JlZUNyZWRlbnRpYWwiXSwgImlzc3VlciI6ICJodHRwczovL3JlZ2lzdHJ5X2Jhc2UvaXNzdWVyLzcyZDkwYjQ0LWZkM2MtNDYzOC1hZWM3LTBiNjFhM2ZlOGM5ZCIsICJjcmVkZW50aWFsU3ViamVjdCI6IHsiZGVncmVlIjogeyJfc2QiOiBbIk9mNk9sNjQ1Qkg3Q0MwcjA0UnR3Y0xrWDZucVRBbTRrTDFQaEFKaUZQV2MiLCAiYlpqZ0lDWTZMNmx2U1lQbmxHdTgtblNHbnB5STg2NVdobFV4OU1XQlJHMCIsICJrcHYyR3A2S0ZyNHdNdThEbmF4ckEteG5mYlZCQUk5RElwUkFpLTU5dzBRIl19LCAiaWQiOiAiZGlkOmp3azpleUpqY25ZaU9pQWlVQzAxTWpFaUxDQWllQ0k2SUNJelRYRlVZVUpyUzE5alMyMU9aR1YzVVZFM2NWcGlUVE5aVUdobkxYTmxhek5tV2tkcFYwdFRZa0ZJU0VKTmVITkZNSEJzYTJwNGRtZGxjek52VWtwblRWWjZSbDlUWjFab01HMTNiR1V4V0VWSWF6bElaWE1pTENBaWVTSTZJQ0pCWVRCeU4wdFJTMmczVTJOTlNFRmpjbnBPYVhRM1ZIUkZiemRHU2xGQ1QzUkZkM1V5Um5sSFpreHBYMUExWW5sblF6RjBPVTlFVTJJelJteGhPR052TWtjNFJXTlhhVE4yTTA1SlNXOTRhMFp1UW1FNGFFSTBJaXdnSW10MGVTSTZJQ0pGUXlJc0lDSnJhV1FpT2lBaVYyTm5ZbTUwVDNwUllqSlJjelJMYjBObGJGcDJkMUpNTkdOVldUZFdWMGRFVUdST1pVVnFha05SU1NKOSJ9LCAiY3JlZGVudGlhbFN0YXR1cyI6IHsiaWQiOiAiaHR0cHM6Ly9yZWdpc3RyeV9yZXZvY2F0aW9uL2lzc3Vlci83MmQ5MGI0NC1mZDNjLTQ2MzgtYWVjNy0wYjYxYTNmZThjOWQvc3RhdHVzbGlzdC82ZDI4MDc3OS0wZmEyLTRjYjctYTMwNi00NTczZDY4NWRmZDQjMjQ5IiwgInR5cGUiOiAiU3RhdHVzTGlzdDIwMjFFbnRyeSIsICJzdGF0dXNQdXJwb3NlIjogInJldm9jYXRpb24iLCAic3RhdHVzTGlzdEluZGV4IjogIjI0OSIsICJzdGF0dXNMaXN0Q3JlZGVudGlhbCI6ICJodHRwczovL3JlZ2lzdHJ5X2Jhc2UvaXNzdWVyLzcyZDkwYjQ0LWZkM2MtNDYzOC1hZWM3LTBiNjFhM2ZlOGM5ZCJ9fSwgIl9zZF9hbGciOiAic2hhLTI1NiJ9.AQhQKRWjyqH-AlBiQFR273KjiNx9KiuAS0Kg8oMsWK8bcZBzrxp0u6v8Lt135uILMqPdB6BR9O391Mlos_OfbMVXAO6hpS2cnwbhgsPmyVXrQo7tBFhJuetoBJyJW0UVKmIMEeHeCAO64EPlZtvfgejy1P29ZUMf8zJH-_pHh8vyDwys~WyJhTGZoRl9CRWh0NWtxX2RnZGhFaTJBIiwgInR5cGUiLCAiTWFzdGVyRGVncmVlIl0~"}'
OID_PRESENTATION_JWT = '{"state": "a541a39b-2e52-425c-bc76-9a1c3dda6108", "vp_token": "eyJhbGciOiJFUzUxMiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJkaWQ6andrOmV5SmpjbllpT2lBaVVDMDFNakVpTENBaWVDSTZJQ0pWVm14elNVVlhVbkJhYkUwM1dXTXpOMnAzVmpFMFlXNDBjWFkwZEVnM2FUSnJVRGMwWlhCR1NqbGZlWFp2Y2xwbk0xVkNOWFoxUTNCRlFrcEtRMng0ZWtGVFpFSm5UVWRrUzNoS1FWUlVWVUl5U1hodVRrRWlMQ0FpZVNJNklDSkJZa1oxZHprMldtSnlObVY2U2xWdFVrTktlVE5ZY1dScFltSkZTV2MxWTJwdk1GUkJPVk5sWjBreVZHTjFjV3h6VDFWRGIyWnViMWN4UkcxMVJrdDJXVFZZTVd0TlpuVkJOWFkwYVZCZlZIVk1TRjlMWWs5MUlpd2dJbXQwZVNJNklDSkZReUlzSUNKcmFXUWlPaUFpZVZad09FZE1TVGh3YWxWc2VtVkZYMHN5U0RsVFJtZzFOREIzV0hKTFZGUjFSVEJyU1RWalNsaDBUU0o5IiwianRpIjoiMmVmZGQyZjJlNjdkNDRkYmE4ZDUwM2FjZTRjNWNhOTYiLCJub25jZSI6IjY5NGRkZDYxNzQ0YjQ4OWRhYzg0MTUzZGEyOTQxNjc5IiwidnAiOnsidHlwZSI6WyJWZXJpZmlhYmxlUHJlc2VudGF0aW9uIl0sInZlcmlmaWFibGVDcmVkZW50aWFsIjpbImV5SjBlWEFpT2lKS1YxUWlMQ0poYkdjaU9pSkZVelV4TWlKOS5leUpwYzNNaU9pSTNPVE5pTmpreU5DMW1OR0U1TFRSak9HUXRPR1l5WmkwMU0yRmtZbVF6WW1KbU5qQWlMQ0pwWVhRaU9qRTJPVEkyTXpJNE56a3NJbVY0Y0NJNk1UY3lNamczTWpnM09Td2lhblJwSWpvaWFIUjBjSE02THk5cGMzTjFaWEl2TmpkaFl6WmlZVGd0TkRBeU5pMDBObVV4TFRsa09UVXRObVk0TWpjNVptVmhZbVZpSWl3aWMzVmlJam9pWkdsa09tcDNhenBsZVVwcVkyNVphVTlwUVdsVlF6QXhUV3BGYVV4RFFXbGxRMGsyU1VOS1ZsWnRlSHBUVlZaWVZXNUNZV0pGTUROWFYwMTZUakp3TTFacVJUQlpWelF3WTFoWk1HUkZaek5oVkVweVZVUmpNRnBZUWtkVGFteG1aVmhhZG1Oc2NHNU5NVlpEVGxoYU1WRXpRa1pSYTNCTFVUSjROR1ZyUmxSYVJVcHVWRlZrYTFNemFFdFJWbEpWVmxWSmVWTllhSFZVYTBWcFRFTkJhV1ZUU1RaSlEwcENXV3RhTVdSNmF6SlhiVXA1VG0xV05sTnNWblJWYTA1TFpWUk9XV05YVW5CWmJVcEdVMWRqTVZreWNIWk5SbEpDVDFaT2JGb3dhM2xXUjA0eFkxZDRlbFF4VmtSaU1scDFZakZqZUZKSE1URlNhM1F5VjFSV1dVMVhkRTVhYmxaQ1RsaFpNR0ZXUW1aV1NGWk5VMFk1VEZsck9URkphWGRuU1cxME1HVlRTVFpKUTBwR1VYbEpjMGxEU25KaFYxRnBUMmxCYVdWV1duZFBSV1JOVTFSb2QyRnNWbk5sYlZaR1dEQnplVk5FYkZSU2JXY3hUa1JDTTFkSVNreFdSbEl4VWxSQ2NsTlVWbXBUYkdnd1ZGTktPU0lzSW5aaklqcDdJa0JqYjI1MFpYaDBJanBiSW1oMGRIQnpPaTh2ZDNkM0xuY3pMbTl5Wnk5dWN5OWpjbVZrWlc1MGFXRnNjeTkyTWlKZExDSnBaQ0k2SW1oMGRIQnpPaTh2YVhOemRXVnlMelkzWVdNMlltRTRMVFF3TWpZdE5EWmxNUzA1WkRrMUxUWm1PREkzT1dabFlXSmxZaUlzSW5SNWNHVWlPaUpWYm1sMlpYSnphWFI1UkdWbmNtVmxRM0psWkdWdWRHbGhiQ0lzSW1semMzVmxjaUk2SWpjNU0ySTJPVEkwTFdZMFlUa3ROR000WkMwNFpqSm1MVFV6WVdSaVpETmlZbVkyTUNJc0ltTnlaV1JsYm5ScFlXeFRkV0pxWldOMElqcDdJbVJsWjNKbFpTSTZleUowZVhCbElqb2lRbUZqYUdWc2IzSkVaV2R5WldVaUxDSnVZVzFsSWpvaVFtRmphR1ZzYjNJZ2IyWWdRWEowY3lJc0ltRjJaWEpoWjJWZlozSmhaR1VpT2pRdU5ESjlMQ0pwWkNJNkltUnBaRHBxZDJzNlpYbEthbU51V1dsUGFVRnBWVU13TVUxcVJXbE1RMEZwWlVOSk5rbERTbFpXYlhoNlUxVldXRlZ1UW1GaVJUQXpWMWROZWs0eWNETldha1V3V1ZjME1HTllXVEJrUldjellWUktjbFZFWXpCYVdFSkhVMnBzWm1WWVduWmpiSEJ1VFRGV1EwNVlXakZSTTBKR1VXdHdTMUV5ZURSbGEwWlVXa1ZLYmxSVlpHdFRNMmhMVVZaU1ZWWlZTWGxUV0doMVZHdEZhVXhEUVdsbFUwazJTVU5LUWxscldqRmtlbXN5VjIxS2VVNXRWalpUYkZaMFZXdE9TMlZVVGxsalYxSndXVzFLUmxOWFl6RlpNbkIyVFVaU1FrOVdUbXhhTUd0NVZrZE9NV05YZUhwVU1WWkVZakphZFdJeFkzaFNSekV4VW10ME1sZFVWbGxOVjNST1dtNVdRazVZV1RCaFZrSm1Wa2hXVFZOR09VeFphemt4U1dsM1owbHRkREJsVTBrMlNVTktSbEY1U1hOSlEwcHlZVmRSYVU5cFFXbGxWbHAzVDBWa1RWTlVhSGRoYkZaelpXMVdSbGd3YzNsVFJHeFVVbTFuTVU1RVFqTlhTRXBNVmtaU01WSlVRbkpUVkZacVUyeG9NRlJUU2praWZTd2lZM0psWkdWdWRHbGhiRk4wWVhSMWN5STZleUpwWkNJNkltaDBkSEJ6T2k4dmNtVm5hWE4wY25sZmNtVjJiMk5oZEdsdmJpOXBjM04xWlhJdk56a3pZalk1TWpRdFpqUmhPUzAwWXpoa0xUaG1NbVl0TlROaFpHSmtNMkppWmpZd0wzTjBZWFIxYzJ4cGMzUXZPR0kzTkdGbE56VXRaREpqWVMwMFlXSXhMV0UwTjJRdFltRm1aVFkxTVRnME1Ea3lJemN5SWl3aWRIbHdaU0k2SWxOMFlYUjFjMHhwYzNReU1ESXhSVzUwY25raUxDSnpkR0YwZFhOUWRYSndiM05sSWpvaWNtVjJiMk5oZEdsdmJpSXNJbk4wWVhSMWMweHBjM1JKYm1SbGVDSTZJamN5SWl3aWMzUmhkSFZ6VEdsemRFTnlaV1JsYm5ScFlXd2lPaUpvZEhSd2N6b3ZMM0psWjJsemRISjVYMkpoYzJVdmFYTnpkV1Z5THpjNU0ySTJPVEkwTFdZMFlUa3ROR000WkMwNFpqSm1MVFV6WVdSaVpETmlZbVkyTUNKOWZYMC5BUVBkSUM2eGV6ZU9TeHpvSGhxS2ZhU081REw4RjgxLXozbnM1WFlScnpBZVMxOXdxSlpQaHZrY1pPZVFTeFUxSUFUVEdnTW5XbUtWbFh0ekNiVFJiVmZEQU54S3JyM3IzTDRLTjFSZF9vSy1ZQjI0MGV0UUhhc3lkdjIzVWZGOVJOX0tkYVdIcmRyMHdLLXBuXzdIUERFam1hZVgyZ3ZVcTlJZ1Bxd3JMaFdYOTZTeiJdfX0.AR1yWXvGgJ7HWfRA66qjFN2tdh-uniMk33AOLtX8X5zQyWmREiGl7smN3EO0ZKvU2mDueC0zj_KUJVM7DyhypHGuAED4PvNupRdUzmIOcxdYi9AfJVfYzrMy3bGHVRJ9-_3s0gkoWvRUCgLaCPMBf1NRRnZ00kT_zIeU07C5JsNwAQbt", "presentation_submission": {"id": "Fake", "definition_id": "News", "descriptor_map": [{"id": "One", "format": "jwt_vp_json", "path": "$", "path_nested": {"path": "$.vp.verifiableCredential[0]", "format": "jwt_vc"}}]}}'


def test_jwt_unpacking():
    cred = vc.OpenID4VerifiableCredentialJWT.model_validate_json(OID_CREDENTIAL)
    assert cred.format == "jwt_vc", "the format should be available"
    jwt = cred.jwt
    assert jwt.to_raw() == cred.credential, "Parsing and rebuilding the credentail should not change the credential"
    assert isinstance(jwt, vc.JsonWebToken) and not isinstance(jwt, vc.SelectiveDisclosureJsonWebToken), "The Token is not an SD-JWT and should not be handeled as one"
    assert jwt.head.alg and jwt.head.alg == "ES512", "Algorithm is read"
    assert jwt.head.typ, "Type is read"
    assert jwt.body.iat < jwt.body.exp, "Issued at and expire is read"
    assert jwt.body.jti, "JWT has an ID"
    assert jwt.body.sub, "subject exists"
    assert isinstance(jwt.body, vc.JsonWebTokenBodyVCData), "The jwt_vc should be a"
    assert jwt.body.vc.issuer, "Isser must exist"
    assert not jwt.body.vp, "Test Credential is a VC, not a VP"
    assert jwt.body.vc.credentialStatus.type, "Credential status type has to be set"
    assert jwt.body.vc.credentialSubject, "Credential Subject must contain the claims, the shape of which are dependent on type"
    assert jwt.body.vc.credentialSubject.degree['type'], "Should find the type of the degree"
    assert jwt.body.vc.credentialStatus, "Should have a statuslist entry"
    assert isinstance(jwt.body.vc.credentialStatus, vc.StatusList2021Entry)
    assert "StatusList2021Entry" in jwt.body.vc.credentialStatus.type

    redumped_cred = cred.model_dump(exclude_none=True)
    assert 'format' in redumped_cred, "OID4VC Format must be present"
    assert 'credential' in redumped_cred, "Credential must be present in the dumped data"
    assert isinstance(redumped_cred['credential'], str), "Credential should be a jwt string"

    assert 'jwt' not in redumped_cred, "Unpacked JWT may not be present"


def _sd_jwt_unpacking(sd_jwt: str) -> vc.OpenID4VerifiableCredentialJWT:
    cred = vc.OpenID4VerifiableCredentialJWT.model_validate_json(sd_jwt)
    assert cred.format == "jwt_vc", "the format should be available"
    jwt = cred.jwt
    assert jwt.to_raw() == cred.credential, "Parsing and rebuilding the credentail should not change the credential"
    assert isinstance(jwt, vc.SelectiveDisclosureJsonWebToken), "The Token is not an SD-JWT and should not be handeled as one"
    assert jwt.head.alg and jwt.head.alg == "ES512", "Algorithm is read"
    # assert jwt.head.typ, "Type is read" # TODO -> EID-1242: Re-Add Test & Improve with sepecific type once issuer/builder.py is fixed to create it correctly
    assert jwt.body.iat < jwt.body.exp, "Issued at and expire is read"
    assert jwt.body.jti, "JWT has an ID"
    assert jwt.body.sub, "subject exists"
    assert jwt.body._sd_alg, "Should have the algorithm used in sd"
    assert isinstance(jwt.body, vc.JsonWebTokenBodyVCData), "The jwt_vc should be a"
    assert jwt.body.vc.issuer, "Isser must exist"
    assert not jwt.body.vp, "Test Credential is a VC, not a VP"
    assert jwt.body.vc.credentialStatus.type, "Credential status type has to be set"
    assert jwt.body.vc.credentialSubject, "Credential Subject must contain the claims, the shape of which are dependent on type"
    assert jwt.body.vc.credentialStatus, "Should have a statuslist entry"
    assert isinstance(jwt.body.vc.credentialStatus, vc.StatusList2021Entry)
    assert "StatusList2021Entry" in jwt.body.vc.credentialStatus.type
    return cred


def test_sd_jwt_unpacking():
    cred = _sd_jwt_unpacking(OID_SD_CREDENTIAL_ALL_DISCLOSED)
    sd_jwt = vc.SelectiveDisclosureJsonWebToken.from_str(cred.credential)
    assert '_sd' in sd_jwt.body.vc.credentialSubject.degree, "Should find the _sd part"
    assert 'average_grade' in sd_jwt.body.vc.credentialSubject.degree, "Should find the average_grade"
    cred = _sd_jwt_unpacking(OID_SD_CREDENTIAL_PARTS_DISCLOSED)
    sd_jwt = vc.SelectiveDisclosureJsonWebToken.from_str(cred.credential)
    assert '_sd' in sd_jwt.body.vc.credentialSubject.degree, "Should find the _sd part"
    assert 'average_grade' not in sd_jwt.body.vc.credentialSubject, "Should not find the average_grade"

    redumped_cred = cred.model_dump(exclude_none=True)
    assert 'format' in redumped_cred, "OID4VC Format must be present"
    assert 'credential' in redumped_cred, "Credential must be present in the dumped data"
    assert isinstance(redumped_cred['credential'], str), "Credential should be a jwt string"

    assert 'jwt' not in redumped_cred, "Unpacked JWT may not be present"


def test_oid_presentation():
    cred = vc.OpenID4VerifiablePresentationResponse.model_validate_json(OID_PRESENTATION_JWT)
    jwt = vc.JsonWebToken.model_validate(cred.vp_token_jwt)
    assert cred.vp_token == jwt.to_raw(), "Parsing and rebuilding the credentail should not change the credential"
    jwt.body
    assert jwt.body.iss, "Should have an issuer"
    assert isinstance(jwt.body, vc.JsonWebTokenBodyVCData), "Should be detected as VC Data"
    assert jwt.body.vp, "Should have a Verifiable Presentation"
    assert not jwt.body.vc, "Should not have a Verifiable Credential at this level"
    assert jwt.body.vp.type == "VerifiablePresentation" or "VerifiablePresentation" in jwt.body.vp.type, "Type of VP should be VerifiablePresentation"


def test_validity_date_parsing():
    """Test the parsing for validFrom & validUntil which should be XMLSchema (ISO8601) format"""

    def validation_passes(valid_from: str = None, valid_until: str = None) -> bool:
        try:
            vc.W3CData(
                type=["Test"],
                validFrom=valid_from,
                validUntil=valid_until,
            )
            return True
        except pydantic.ValidationError:
            return False

    # Not ISO8601
    assert not validation_passes(valid_from="01.01.1970")
    assert not validation_passes(valid_until="01.01.1970")
    assert not validation_passes(valid_from="01.01.1970", valid_until="01.01.1970")
    assert not validation_passes(valid_from="Hello World")
    # ISO8601
    assert validation_passes(valid_from='1970-01-01')
    assert validation_passes(valid_until='1970-01-01')
    assert validation_passes(
        valid_from='1970-01-01',
        valid_until=datetime.date.today().isoformat(),
    ), "Should work with day dates"
    assert validation_passes(
        valid_from='1970-01-01T01:23:45.6789',
        valid_until=datetime.datetime.now().isoformat(),
    ), "should work without timezone"
    assert validation_passes(
        valid_from='1970-01-01T01:23:45.6789Z',
        valid_until=datetime.datetime.utcnow().isoformat(),
    ), "should work with timezones"
