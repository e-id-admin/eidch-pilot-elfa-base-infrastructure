# SPDX-FileCopyrightText: 2024 Swiss Confederation
#
# SPDX-License-Identifier: MIT

from collections.abc import Mapping
import json
from datetime import datetime
import logging
from typing import Any

import pydantic

_logger = logging.getLogger(__name__)


class SplunkExtendedLogEntry(pydantic.BaseModel):
    """Container for splunk compatible logging."""

    message: str = pydantic.Field(..., exclude=True)

    class Config:
        use_enum_values = True

    def __str__(self) -> str:
        """Summarizes the log entry.

        Example:
            Successfully delivered credential. status=SUCCESS operation=ISSUANCE step=DELIVERY seconds_until_expiry=3600.3228483200073

        Returns:
            str: Format: <message> <attr1.name>=<attr1.value> <attr2.name>=<attr2.value>
        """
        ret = f"{self.message}"
        fields: str = self.model_dump_json(exclude_defaults=True)
        fields: dict[str, object] = json.loads(fields)
        for k, v in fields.items():
            ret += f" {k}={v}"
        return ret


class Iso8601UTCTimeFormatter(logging.Formatter):
    """Formatter with the time formatter set to be Iso8601 compatible."""

    def formatTime(self, record, datefmt=None):
        return datetime.fromtimestamp(record.created).astimezone().isoformat(timespec='milliseconds')


class SplunkFormatter(Iso8601UTCTimeFormatter):
    """
    Formatter which transforms the log entries into a splunk compatible JSON structure.

    All newline characters get escaped to allow for easier ingestion.

    Example:
        {"@timestamp": "2024-02-14T09:41:20.367+00:00", "app":"your_app", "level": "INFO", "hash":"9cb189d0-3508-4ca1-b862-0ba8186a6804", "logger":"logging_config", "message":"Hello\\nworld"}
    """

    def __init__(self, defaults: Mapping[str, Any] | None = None) -> None:
        fmt = '"@timestamp": "%(asctime)s", '
        fmt += '"app":"%(app_name)s", '
        fmt += '"level": "%(levelname)s", '
        fmt += '"hash":"%(correlation_id)s", '
        fmt += '"logger":"%(name)s", '
        fmt += '"message":%(message)s'
        super().__init__(fmt, defaults=defaults)

    def format(self, record):

        s = "{" + super(SplunkFormatter, self).format(record)
        search_index = ', "message":'
        actual_message_idx = s.index(search_index) + len(search_index)
        s = s[:actual_message_idx] + json.dumps(s[actual_message_idx:])
        # using json.dumps to actually escape the log message / stack trace etc

        if isinstance(record.msg, SplunkExtendedLogEntry):
            s += "," + record.msg.model_dump_json(exclude_defaults=True)[1:-1]
            # cut the { and } to integrate this json into the one generated by the baseclass
        s += "}"
        return s.replace('\n', '\\n')  # make the result a one liner to be imported in one go
